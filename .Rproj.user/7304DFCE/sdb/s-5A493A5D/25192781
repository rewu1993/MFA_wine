{
    "collab_server" : "",
    "contents" : "# Defin MFA in S4 Class\nsetClass(\n  Class = \"mfa\",\n  representation = representation(\n    eigenvalues = \"numeric\",\n    cfs = \"matrix\",\n    pfs = \"list\",\n    mol = \"list\",\n    alpha = \"numeric\"\n  ),\n\n  # It seems that we dont need to valid anything\n\n  # validity = function(object){\n  #   }\n\n  # A simple prototype\n  prototype = prototype(\n    eigenvalues = c(0,0,0,0),\n    cfs = matrix(0, 10, 10),\n    pfs = list(matrix(0, 10, 10)),\n    mol = list(matrix(0, 10, 10)),\n    alpha = c(0,0,0,0)\n\n  )\n\n)\n\n#private function to check if dataset is matrix or dataframe\ncheck_dataset <- function(dataset){\n\n  if((class(dataset) != \"matrix\") & (class(dataset) != \"data.frame\")){\n\n    stop(\"\\n'dataset' must be a of class 'matrix' or of class 'data.frame'\")\n\n  }\n  TRUE\n}\n\n#private function to check if sets is a list and is composed of numeric vectors\ncheck_sets <- function(sets){\n\n  if(class(sets) != \"list\"){\n\n    stop(\"\\n'sets' must be a of class 'list'\")\n\n  }\n\n  for(i in 1:length(sets)){\n\n    if((class(sets[[i]]) != \"integer\") &\n       (class(sets[[i]]) != \"numeric\") &\n       (class(sets[[i]]) != \"character\")){\n\n      stop(\"\\n'sets' must contain integer, numeric, or character vectors\")\n\n    }\n\n  }\n  TRUE\n}\n\n#private function to check if ncomps is an integer\ncheck_ncomps <- function(ncomps){\n\n  if((class(ncomps) != \"integer\") & (class(ncomps) != \"numeric\")){\n\n    stop(\"\\n'ncomps' must be an integer\")\n\n  }\n\n  if(ncomps %% 1 != 0){\n\n    stop(\"\\n'ncomps' must be an integer\")\n\n  }\n  TRUE\n}\n\n#private function to check if center is a logical or numeric vector\ncheck_center <- function(center){\n\n  if((class(center) != \"logical\") & (class(center) != \"numeric\")){\n\n    stop(\"\\n'center' must be a logical or numeric vector\")\n\n  }\n  TRUE\n}\n\n#private function to check if scale is a logical or numeric vector\ncheck_scale <- function(scale){\n\n  if((class(scale) != \"logical\") & (class(scale) != \"numeric\")){\n\n    stop(\"\\n'scale' must be a logical or numeric vector\")\n\n  }\n  TRUE\n}\n\n# A library for GSVD Computation\nlibrary(MFAg)\n# public constructer function\n\n#' @title mfa_const\n#' @description Creates an object of class \\code{\"mfa\"}\n#' @param data data set (matrix or data frame)\n#' @param sets list of vectors indicating the sets of variables (i.e. the blocks)\n#' @param ncomps integer indicating how many number of components (i.e. factors) are to be extracted\n#' @param center logical value\n#' @param scale logical value\n#' @return an object of class mfa\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' test <- mfa_const(data = simulate_data, sets = list(1:3, 4:5, 6:10), ncomps = 2)\n#'\nmfa_const <- function(data, sets, ncomps = NULL, center = TRUE, scale = TRUE){\n\n  check_dataset(data)\n  check_sets(sets)\n  check_ncomps(ncomps)\n  check_center(center)\n  check_scale(scale)\n\n  # Separate the grand table into small tables, and record the names of table\n  table_name = c()\n  for (i in 1:(length(sets))){\n    assign(paste(\"x\",i ,sep=\"\"), data[,sets[[i]]])\n    # record the names of individual tables\n    table_name = append(table_name, paste(\"x\",i ,sep=\"\"))\n  }\n\n\n  # Normalize all the data set, and combine the normalized data set\n  alpha = c()\n  combined_X = c()\n  normtable_name = c()\n  for (i in table_name){\n    # Center the data set\n    tmp = scale(eval(as.name(paste(i))) , center = center,  scale = F)\n\n    #Scale the data set (depend on the scale input)\n    if (scale){\n      # compute the scale array\n      scale_array = sqrt(apply(tmp^2,2,sum))\n      # Scale the nomalized matrix\n      norm_x = scale(tmp, center = F, scale = scale_array)\n    }\n    else{\n      norm_x = tmp\n    }\n\n\n    # alpha weight vector\n    alpha = append(alpha, rep(1,length(svd(norm_x)$d)) * (1/(svd(norm_x)$d[1])^2) )\n\n    # record the normalized individual table\n    assign(paste(\"norm\",i ,sep=\"\"), norm_x)\n    normtable_name = append(normtable_name, paste(\"norm\",i ,sep=\"\"))\n\n    # combined normalized matrx\n    combined_X = as.matrix(cbind(combined_X,norm_x))\n    # assign(paste(\"SVD\",i ,sep=\"\"), svd(norm_x))\n  }\n\n  # Create matrix for A\n  A = diag(alpha, length(alpha),length(alpha))\n  # Create vector for M\n  n = length(data[,1])\n  # M = diag(rep(1/n, n),n, n)\n  M = rep(1/n, n)\n\n  # GSVD!!\n  GSVD = GSVD(combined_X, PLin = M, PCol = alpha)\n\n  # Eigen values\n  eigenvalues = (GSVD$d)^2\n\n  # eigen value in matrix form\n  d_mat = diag(GSVD$d , length(GSVD$d), length(GSVD$d))\n\n  # Factor scores\n  f = GSVD$u %*% d_mat\n\n  # Q\n  Q = GSVD$v\n\n  # Partial factor scires\n  K = length(table_name)\n  tmp = 1\n  pfs = list()\n  mol = list()\n  for (i in 1:K){\n    x = eval(as.name(paste(normtable_name[i])))\n    Q_tmp = Q[tmp:(tmp+length(x[1,])-1),]\n    pfs_tmp = K*alpha[tmp]*x%*%Q_tmp\n    tmp = tmp+length(x[1,])\n    mol[[i]] = Q_tmp\n    pfs[[i]] = pfs_tmp\n\n  }\n\n\n\n  # If ncomps is specified\n  if (!is.null(ncomps)){\n    eigenvalues = eigenvalues[1:ncomps]\n    f = f[,1:ncomps]\n    # pfs and mol is a list, so for loop it...\n    for (i in 1:K){\n      pfs[[i]] = pfs[[i]][,1:ncomps]\n      mol[[i]] = mol[[i]][,1:ncomps]\n    }\n  }\n\n\n  # Set the new class\n  new(\n    Class = \"mfa\",\n    eigenvalues = eigenvalues,\n    cfs = f,\n    pfs = pfs ,\n    mol = mol,\n    alpha = alpha\n  )\n\n\n}\n\n\n#print method\n#' @export\nsetMethod(\n  \"print\",\n  signature = \"mfa\",\n  function(x, ...) {\n    cat('object \"mfa\"\\n\\n')\n    cat(\"eigenvalues: \", x@eigenvalues, \"\\n\\n\")\n    cat(\"cfs: \\n\")\n    print(x@cfs)\n  }\n)\n\n#Compromise of the 10 tables:\n\nlibrary(ggplot2)\nlibrary(png)\nlibrary(gridGraphics)\n\n\n#' @title Plot of Compromise of Tables\n#' @description Takes two dimensions of compromise of tables and returns a plot of the two dimensions\n#' @param dimension1 vector of class \\code{\"numeric\"}\n#' @param dimension2 vector of class \\code{\"numeric\"}\n#' @param rownames_vec vector of row labels\n#' @param img1 optional image of class \\code{\"png\"}\n#' @param img2 optional image of class \\code{\"png\"}\n#' @param img3 optional image of class \\code{\"png\"}\n#' @return plot of compromise of tables\n#' @export\n#' @examples\n#'\n#' dimension1 <- rnorm(20)\n#' dimension2 <- rnorm(20)\n#' plot_compromise(dimension1, dimension2)\n#'\nplot_compromise <- function(dimension1,\n                            dimension2,\n                            rownames_vec = as.character(1:length(dimension1)),\n                            img1 = \"black\",\n                            img2 = \"black\",\n                            img3 = \"black\"){\n\n  dat <- data.frame(x = dimension1, y = dimension2, label = rownames_vec)\n  colnames(dat) <- c(\"x\",\"y\")\n\n  ggplot(dat)+ geom_point(aes(x,y)) +labs(title=\"Compromise of the tables\",\n                                          x =\"1\", y = \"2\")+  ylim(-1, 1) + geom_text(data = dat, aes(x,y, label = rownames_vec), vjust = -2)+\n    mapply(function(xx, yy)\n      annotation_raster(img1, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[1:4], dat$y[1:4]) +\n    mapply(function(xx, yy)\n      annotation_raster(img2, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[5:8], dat$y[5:8]) +\n    mapply(function(xx, yy)\n      annotation_raster(img3, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[9:12], dat$y[9:12]\n    )\n\n}\n\n#' @title Plot of Partial Factor Scores\n#' @description Takes two dimensions of partial factor scores and returns a plot of the two dimensions\n#' @param dimension1 vector of class \\code{\"numeric\"}\n#' @param dimension2 vector of class \\code{\"numeric\"}\n#' @param rownames_vec vector of row labels\n#' @param img1 optional image of class \\code{\"png\"}\n#' @param img2 optional image of class \\code{\"png\"}\n#' @param img3 optional image of class \\code{\"png\"}\n#' @return plot of partial factor scores\n#' @export\n#' @examples\n#'\n#' dimension1 <- rnorm(20)\n#' dimension2 <- rnorm(20)\n#' plot_compromise(dimension1, dimension2)\n#'\nplot_pfs <- function(dimension1,\n                     dimension2,\n                     rownames_vec = as.character(1:length(dimension1)),\n                     img1 = \"black\",\n                     img2 = \"black\",\n                     img3 = \"black\"){\n\n  dat <- data.frame(x = dimension1, y = dimension2, label = rownames_vec)\n\n  ggplot(dat)+labs(title=\"Partial Factor Scores\",\n                               x =\"1\", y = \"2\") + geom_text(data = dat, aes(x,y, label = rownames_vec), vjust = -0.5)+ xlim(-1.5,1.8) + ylim(-1.3,1.3) +\n    mapply(function(xx, yy)\n      annotation_raster(img1, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[1:4], dat$y[1:4]) +\n    mapply(function(xx, yy)\n      annotation_raster(img2, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[5:8], dat$y[5:8]) +\n    mapply(function(xx, yy)\n      annotation_raster(img3, xmin=xx-0.08, xmax=xx+0.08, ymin=yy-0.04, ymax=yy+0.04),\n      dat$x[9:12], dat$y[9:12])\n\n}\n\n#' @title Plot of Variable Loadings\n#' @description Takes two dimensions of variable loadings and returns a plot of the two dimensions\n#' @param dimension1 vector of class \\code{\"numeric\"}\n#' @param dimension2 vector of class \\code{\"numeric\"}\n#' @param rownames_vec vector of row labels\n#' @return plot of variable loadings\n#' @export\n#' @examples\n#'\n#' dimension1 <- rnorm(20)\n#' dimension2 <- rnorm(20)\n#' plot_compromise(dimension1, dimension2)\n#'\nplot_vload <- function(dimension1,\n                       dimension2,\n                       rownames_vec = as.character(1:length(dimension1))){\n\n  dat <- data.frame(x = dimension1, y = dimension2, label = rownames_vec)\n\n  ggplot(dat) +\n    geom_point(aes(x,y)) +\n    labs(title=\"Variable loadings\", x =\"1\", y = \"2\") +\n    geom_text(data = dat, aes(x,y, label = rownames_vec), vjust = -0.5) +\n    xlim(-0.5,0.5) +\n    ylim(-0.6,0.6)\n\n}\n\n#' @title eigen_table\n#' @description Takes the \\code{\"mfa\"} object and returns a table with the singular values (i.e. square root of eigenvalues), the eigenvalues, cumulative, percentage of intertia, cumulative percentage of inertia, for all the extracted components\n#' @param object an object of class \\code{\"mfa\"}\n#' @return object of class \\code{\"data.frame\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' test <- mfa_const(simulate_data, sets = list(1:3, 4:5, 6:10), ncomps = 2)\n#'\n#' eigen_table(test)\n#'\n# Generic Methods\nsetGeneric(\n  \"eigen_table\",\n  function(object) standardGeneric(\"eigen_table\")\n)\n\n# Set the method for S4 class\nsetMethod(\n  \"eigen_table\",\n  signature = \"mfa\",\n  function(object){\n    # Everything is based on eigenvalues\n    eigenval = object@eigenvalues\n\n    #  Create the data frame with a sample column\n    samp = c(0,0,0,0,0)\n    # rownames\n    rownames = c(\"Singular value\",\"Eigenvalue\",\"cumulative E\",\"% Inertia\",\"cumulative I\")\n    df = data.frame(samp,row.names = rownames)\n    # for loop for creating different arrays\n    for (i in 1:(length(eigenval))){\n      tmp_arr = c()\n\n      tmp_sv = sqrt(eigenval[i])\n      tmp_arr = append(tmp_arr,tmp_sv)\n\n      tmp_ev = eigenval[i]\n      tmp_arr = append(tmp_arr,tmp_ev)\n\n      tmp_cumu = sum(df[2,1:i])+tmp_ev\n      tmp_arr = append(tmp_arr,tmp_cumu)\n\n      tmp_inert = (eigenval[i]/sum(eigenval))*100\n      tmp_arr = append(tmp_arr,tmp_inert)\n\n      tmp_cumu_inert = sum(df[4,1:i])+tmp_inert\n      tmp_arr = append(tmp_arr,tmp_cumu_inert)\n\n      assign(paste(\"Comp\",i ,sep=\"\"), tmp_arr)\n      # produce the data frame\n      df[,paste(\"Comp\",i ,sep=\"\")] = tmp_arr\n    }\n    # create the data frame, remove the sample column\n    return(subset(df, select = -samp ))\n\n  }\n\n)\n\n\n#' @title Contribution of an Observation to a Dimension\n#' @description Outputs values that help interpret how the observations contribute to a dimension.\n#' @param object an object of class \\code{\"mfa\"}\n#' @return object of class \\code{\"matrix\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' test <- mfa_const(data = simulate_data, sets = list(1:3, 4:5, 6:10), ncomps = 2)\n#' COD(test)\n#'\n# Generic Methods\nsetGeneric(\n  \"COD\",\n  function(object) standardGeneric(\"COD\")\n)\n# Set the method for S4 class\nsetMethod(\n  \"COD\",\n  signature = \"mfa\",\n  function(object){\n    # Define the mass\n    cfs = object@cfs\n    n = length(cfs[,1])\n    m = 1/n\n    cfs_sq = cfs*cfs\n    ctr = m*cfs_sq\n\n    #scale by eigenvalues\n    eigenval = object@eigenvalues\n    for (i in 1:length(eigenval)){\n      ctr[,i] = ctr[,i]/eigenval[i]\n    }\n    return(ctr)\n  }\n)\n\n\n#' @title Contributions of a Variable to a Dimension\n#' @description Outputs values that help interpret how the variables contribute to a dimension.\n#' @param object an object of class \\code{\"mfa\"}\n#' @return an object of class \\code{\"list\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' test <- mfa_const(data = simulate_data, sets = list(1:3, 4:5, 6:10), ncomps = 2)\n#' CVD(test)\n#'\n# Generic Methods\nsetGeneric(\n  \"CVD\",\n  function(object) standardGeneric(\"CVD\")\n)\n# Set the method for S4 class\nsetMethod(\n  \"CVD\",\n  signature = \"mfa\",\n  function(object){\n    cvd = list()\n    alpha = object@alpha\n    tmp = 0\n    for (i in 1:length(object@mol)){\n      mol = object@mol[[i]]\n      mol_sq = mol*mol\n      tmp = tmp+length(mol[,1])\n      cvd_tmp = alpha[tmp] *mol_sq\n      cvd[[i]] = cvd_tmp\n    }\n    return(cvd)\n  }\n)\n\n\n#' @title Contribution of a Table to a Dimension\n#' @description Outputs values that help interpret how the tables contribute to a dimension. The contribution of a table reﬂects the proportion of the variance of a dimension that can be attributed to this table.\n#' @param object an object of class \\code{\"mfa\"}\n#' @return object of class \\code{\"list\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' test <- mfa_const(data = simulate_data, sets = list(1:3, 4:5, 6:10), ncomps = 2)\n#' CTD(test)\n#'\n# Generic Methods\nsetGeneric(\n  \"CTD\",\n  function(object) standardGeneric(\"CTD\")\n)\n# Set the method for S4 class\nsetMethod(\n  \"CTD\",\n  signature = \"mfa\",\n  function(object){\n    # use CVD method to find Contributions of a Variable to a Dimension\n    cvd = CVD(object)\n    ctd = c()\n    # sum columns to find the\n    for (i in 1:length(cvd)){\n      tmp_ctd = colSums(cvd[[i]])\n      ctd = rbind(ctd,tmp_ctd)\n    }\n    # remove row names\n    rownames(ctd) <- c()\n    return(ctd)\n\n  }\n)\n\n#private function to check if tabe is a matrix\ncheck_table <- function(table){\n\n  if(class(table) != \"matrix\"){\n    stop(\"\\n argument must be a of class 'matrix'\")\n  }\n  TRUE\n}\n\n#private function to check if tabe is a matrix\ncheck_rows <- function(table1, table2){\n\n  if(nrow(table1) != nrow(table2)){\n\n    stop(\"\\n The two tables  must have the same number of rows.\")\n\n  }\n  TRUE\n}\n\n\n#' @title RV Coefficient\n#' @description Use the RV coefficient to evaluate the similarity between two tables\n#' @param table1 an object of class \\code{\"matrix\"} with same number of rows as table 2\n#' @param table2 an object of class \\code{\"matrix\"} with same number of rows as table 1\n#' @return an object of class \\code{\"numeric\"}\n#' @export\n#' @examples\n#'\n#' table1 <- matrix(rnorm(100), nrow = 10)\n#' table2 <- matrix(rnorm(50), nrow = 10)\n#' RV(table1, table2)\n#'\nRV<-function(table1, table2){\n\n  check_table(table1)\n  check_table(table2)\n  check_rows(table1, table2)\n\n  RV = sum(diag(table1%*%t(table1)%*%table2%*%t(table2)))/\n    sqrt(sum(diag(table1%*%t(table1)%*%table1%*%t(table1)))*\n           sum(diag(table2%*%t(table2)%*%table2%*%t(table2))))\n\n  return(RV)\n\n}\n\n#' @title RV Coefficient Table\n#' @description RV coefficient table contains information of how similar the individual tables are to each other pairwise.\n#' @param dataset an object of class \\code{\"matrix\"} or \\code{\"data.frame\"}\n#' @param sets object of class \\code{\"list\"}\n#' @return an object of class \\code{\"matrix\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' RV_table(simulate_data, sets = list(1:3, 4:5, 6:10))\n#'\nRV_table <- function(dataset, sets){\n\n  check_dataset(dataset)\n  check_sets(sets)\n\n  RV_mat <- matrix(NA,nrow = length(sets), ncol = length(sets))\n\n  for(i in 1:length(sets)){\n    for(j in 1:length(sets)){\n\n      table1 = data.matrix(dataset[,sets[[i]]])\n      table2 = data.matrix(dataset[,sets[[j]]])\n      RV_mat[i,j] <- RV(table1, table2)\n\n    }\n  }\n  return(RV_mat)\n}\n\n#' @title Lg Coefficient\n#' @description Computes the Lg coefficient between two tables\n#' @param table1 object of class \\code{\"matrix\"} with same number of rows as table 2\n#' @param table2 object of class \\code{\"matrix\"} with same number of rows as table 1\n#' @return object of class \\code{\"numeric\"}\n#' @export\n#' @examples\n#'\n#' table1 <- matrix(rnorm(100), nrow = 10)\n#' table2 <- matrix(rnorm(50), nrow = 10)\n#' Lg(table1, table2)\n#'\nLg<-function(table1, table2){\n\n  check_table(table1)\n  check_table(table2)\n  check_rows(table1, table2)\n\n  # Center the two tables first\n  tmp_1 = scale(table1 , center = T,  scale = F)\n  tmp_2 = scale(table2 , center = T,  scale = F)\n\n  #Scale the data set (depend on the scale input)\n\n  scale_array_1 = sqrt(apply(tmp_1^2,2,sum))\n  scale_array_2 = sqrt(apply(tmp_2^2,2,sum))\n\n  # Scale to nomalize matrix\n  norm_1 = scale(tmp_1, center = F, scale = scale_array_1)\n  norm_2 = scale(tmp_2, center = F, scale = scale_array_2)\n\n  # alpha weight vector\n  alpha1 = (1/(svd(norm_1)$d[1])^2)\n  alpha2 = (1/(svd(norm_2)$d[1])^2)\n\n  # Find the Lg coefficient\n  Lg = sum(diag(table1%*%t(table1)%*%table2%*%t(table2)))*alpha1*alpha2\n  return(Lg)\n}\n\n#' @title Lg Table\n#' @description Computes a table of Lg coefficients.\n#' @param dataset object of class \\code{\"matrix\"} or \\code{\"data.frame\"}\n#' @param sets object of class \\code{\"list\"}\n#' @return object of class \\code{\"matrix\"}\n#' @export\n#' @examples\n#'\n#' simulate_data <- matrix(rnorm(200), ncol = 10, byrow = TRUE)\n#' Lg_table(simulate_data, sets = list(1:3, 4:5, 6:10))\n#'\nLg_table <- function(dataset, sets){\n\n  check_dataset(dataset)\n  check_sets(sets)\n\n  Lg_mat <- matrix(NA,nrow = length(sets), ncol = length(sets))\n  for(i in 1:length(sets)){\n    for(j in 1:length(sets)){\n      table1 = data.matrix(dataset[,sets[[i]]])\n      table2 = data.matrix(dataset[,sets[[j]]])\n      Lg_mat[i,j] <- Lg(table1, table2)\n\n    }\n  }\n  return(Lg_mat)\n}\n\n\n\n\n",
    "created" : 1480677819797.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1204707605",
    "id" : "25192781",
    "lastKnownWriteTime" : 1480749869,
    "last_content_update" : 1480749869551,
    "path" : "C:/Users/Daniel/Desktop/Fall 2016/Stat 243/mfaR/R/mfa.R",
    "project_path" : "R/mfa.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}